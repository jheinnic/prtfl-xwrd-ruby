<div class="row">
  <%= form_for(@crossword) do |f| %><div class="span5">
    <% if @crossword.errors.any? %>
      <div id="error_explanation">
        <h2><%= pluralize(@crossword.errors.count, "error") %> prohibited this crossword from being saved:</h2>
        <ul>
        <% @crossword.errors.full_messages.each do |msg| %>
          <li><%= msg %></li>
        <% end %>
        </ul>
      </div>
    <% end %>
    <%= f.hidden_field :bonus_value %>
    <%= f.hidden_field :bonus_word %>
    <% tags = ['word01', 'word02', 'word03', 'word04', 'word05', 'word06', 'word07', 'word08', 'word09', 'word10', 'word11', 'word12', 'word13', 'word14', 'word15', 'word16', 'word17', 'word18', 'word19', 'word20', 'word21', 'word22']; %>
    <% tagid = 0; %>
    <%= f.fields_for :word_items do |w| %>
<%= w.hidden_field :x_coordinate, :class=>tags[tagid] %><%= w.hidden_field :y_coordinate, :class=>tags[tagid] %><%= w.hidden_field :is_horizontal, :class => tags[tagid] %><%= w.text_field :text_value, :class=>tags[tagid] + ' xw-initword', :readonly => true %><%= w.hidden_field :triple_letter_index, :class=>tags[tagid] %>

    <% tagid = tagid + 1 %>
    <% end %>
    <%= f.submit %>
  </div>
  <div class="span7">
    <table id="cardroot" class="xw-sliced">
      <tr>
        <td><img src="<%= path_to_image 'card/shim.gif' %>" width="10" height="1" border="0"></td>
        <td><img src="<%= path_to_image 'card/shim.gif' %>" width="42" height="1" border="0"></td>
        <td><img src="<%= path_to_image 'card/shim.gif' %>" width="34" height="1" border="0"></td>
        <td><img src="<%= path_to_image 'card/shim.gif' %>" width="22" height="1" border="0"></td>
        <td><img src="<%= path_to_image 'card/shim.gif' %>" width="112" height="1" border="0"></td>
        <td><img src="<%= path_to_image 'card/shim.gif' %>" width="28" height="1" border="0"></td>
        <td><img src="<%= path_to_image 'card/shim.gif' %>" width="28" height="1" border="0"></td>
        <td><img src="<%= path_to_image 'card/shim.gif' %>" width="84" height="1" border="0"></td>
        <td><img src="<%= path_to_image 'card/shim.gif' %>" width="28" height="1" border="0"></td>
        <td><img src="<%= path_to_image 'card/shim.gif' %>" width="28" height="1" border="0"></td>
        <td><img src="<%= path_to_image 'card/shim.gif' %>" width="24" height="1" border="0"></td>
        <td><img src="<%= path_to_image 'card/shim.gif' %>" width="1" height="1" border="0"></td>
      </tr>
      <tr valign="top">
        <td colspan="11"><img name="card_00" src="<%= path_to_image 'card/card_00.jpg' %>"></td>
      </tr>
      <tr valign="top">
        <td rowspan="5" colspan="2"><img name="card_01" src="<%= path_to_image 'card/card_01.jpg' %>"></td>
        <td rowspan="3" colspan="3">
          <table id="reveal" class="xw-layered">
            <tr>
              <td><div class="xw-cell"><img class="xw-grid" src="<%= path_to_image 'border/grid.png' %>"><img class="xw-fill xw-dark" src="<%= path_to_image 'fill/pink2.png' %>"></div></td>
              <td><div class="xw-cell"><img class="xw-grid" src="<%= path_to_image 'border/grid.png' %>"><img class="xw-fill xw-dark" src="<%= path_to_image 'fill/pink2.png' %>"></div></td>
              <td><div class="xw-cell"><img class="xw-grid" src="<%= path_to_image 'border/grid.png' %>"><img class="xw-fill xw-dark" src="<%= path_to_image 'fill/pink2.png' %>"></div></td>
              <td><div class="xw-cell"><img class="xw-grid" src="<%= path_to_image 'border/grid.png' %>"><img class="xw-fill xw-dark" src="<%= path_to_image 'fill/pink2.png' %>"></div></td>
              <td><div class="xw-cell"><img class="xw-grid" src="<%= path_to_image 'border/grid.png' %>"><img class="xw-fill xw-dark" src="<%= path_to_image 'fill/pink2.png' %>"></div></td>
              <td><div class="xw-cell"><img class="xw-grid" src="<%= path_to_image 'border/grid.png' %>"><img class="xw-fill xw-dark" src="<%= path_to_image 'fill/pink2.png' %>"></div></td>
            </tr>
            <tr>
              <td><div class="xw-cell"><img class="xw-grid" src="<%= path_to_image 'border/grid.png' %>"><img class="xw-fill xw-dark" src="<%= path_to_image 'fill/pink2.png' %>"></div></td>
              <td><div class="xw-cell"><img class="xw-grid" src="<%= path_to_image 'border/grid.png' %>"><img class="xw-fill xw-dark" src="<%= path_to_image 'fill/pink2.png' %>"></div></td>
              <td><div class="xw-cell"><img class="xw-grid" src="<%= path_to_image 'border/grid.png' %>"><img class="xw-fill xw-dark" src="<%= path_to_image 'fill/pink2.png' %>"></div></td>
              <td><div class="xw-cell"><img class="xw-grid" src="<%= path_to_image 'border/grid.png' %>"><img class="xw-fill xw-dark" src="<%= path_to_image 'fill/pink2.png' %>"></div></td>
              <td><div class="xw-cell"><img class="xw-grid" src="<%= path_to_image 'border/grid.png' %>"><img class="xw-fill xw-dark" src="<%= path_to_image 'fill/pink2.png' %>"></div></td>
              <td><div class="xw-cell"><img class="xw-grid" src="<%= path_to_image 'border/grid.png' %>"><img class="xw-fill xw-dark" src="<%= path_to_image 'fill/pink2.png' %>"></div></td>
            </tr>
            <tr>
              <td><div class="xw-cell"><img class="xw-grid" src="<%= path_to_image 'border/grid.png' %>"><img class="xw-fill xw-dark" src="<%= path_to_image 'fill/pink2.png' %>"></div></td>
              <td><div class="xw-cell"><img class="xw-grid" src="<%= path_to_image 'border/grid.png' %>"><img class="xw-fill xw-dark" src="<%= path_to_image 'fill/pink2.png' %>"></div></td>
              <td><div class="xw-cell"><img class="xw-grid" src="<%= path_to_image 'border/grid.png' %>"><img class="xw-fill xw-dark" src="<%= path_to_image 'fill/pink2.png' %>"></div></td>
              <td><div class="xw-cell"><img class="xw-grid" src="<%= path_to_image 'border/grid.png' %>"><img class="xw-fill xw-dark" src="<%= path_to_image 'fill/pink2.png' %>"></div></td>
              <td><div class="xw-cell"><img class="xw-grid" src="<%= path_to_image 'border/grid.png' %>"><img class="xw-fill xw-dark" src="<%= path_to_image 'fill/pink2.png' %>"></div></td>
              <td><div class="xw-cell"><img class="xw-grid" src="<%= path_to_image 'border/grid.png' %>"><img class="xw-fill xw-dark" src="<%= path_to_image 'fill/pink2.png' %>"></div></td>
            </tr>
          </table>
        </td>
        <td rowspan="2" colspan="2"><img name="card_03" src="<%= path_to_image 'card/card_03.jpg' %>"></td>
        <td>
          <table id="bonusvalue" class="xw-sliced">
            <tr>
              <td><img src="<%= path_to_image 'fill/altPath.png' %>"></td>
              <td><img src="<%= path_to_image 'fill/pink2.png' %>"></td>
              <td><img src="<%= path_to_image 'fill/imageSrc.png' %>"></td>
            </tr>
          </table>
        </td>
        <td rowspan="2" colspan="3"><img name="card_05" src="<%= path_to_image 'card/card_05.jpg' %>"></td>
      </tr>
      <tr valign="top">
        <td><img name="card_06" src="<%= path_to_image 'card/card_06.jpg' %>"></td>
      </tr>
      <tr valign="top">
        <td rowspan="2"><img name="card_07" src="<%= path_to_image 'card/card_07.jpg' %>"></td>
        <td colspan="3">
          <table id="bonusword" class="xw-layered">
            <tr>
              <td><div class="xw-cell"><img class="xw-grid" src="<%= path_to_image 'border/grid.png' %>"><img class="xw-fill xw-dark" src="<%= path_to_image 'fill/pink2.png' %>"></div></td>
              <td><div class="xw-cell"><img class="xw-grid" src="<%= path_to_image 'border/grid.png' %>"><img class="xw-fill xw-dark" src="<%= path_to_image 'fill/pink2.png' %>"></div></td>
              <td><div class="xw-cell"><img class="xw-grid" src="<%= path_to_image 'border/grid.png' %>"><img class="xw-fill xw-dark" src="<%= path_to_image 'fill/pink2.png' %>"></div></td>
              <td><div class="xw-cell"><img class="xw-grid" src="<%= path_to_image 'border/grid.png' %>"><img class="xw-fill xw-dark" src="<%= path_to_image 'fill/pink2.png' %>"></div></td>
              <td><div class="xw-cell"><img class="xw-grid" src="<%= path_to_image 'border/grid.png' %>"><img class="xw-fill xw-dark" src="<%= path_to_image 'fill/pink2.png' %>"></div></td>
            </tr>
          </table>
        </td>
        <td rowspan="2" colspan="2"><img name="card_09" src="<%= path_to_image 'card/card_09.jpg' %>"></td>
      </tr>
      <tr valign="top">
        <td colspan="3"><img name="card_10" src="<%= path_to_image 'card/card_10.jpg' %>"></td>
        <td colspan="3"><img name="card_11" src="<%= path_to_image 'card/card_11.jpg' %>"></td>
      </tr>
      <tr valign="top">
        <td colspan="2"><img name="card_12" src="<%= path_to_image 'card/card_12.jpg' %>"></td>
        <td rowspan="3" colspan="6"><table id="lettergrid" class="xw-layered">
              <% for ii in (0..10) do %>
              <tr>
                <td><div data-rowid="<%= ii %>" data-colid="0" data-content="" class="xw-cell">
                <td><div data-rowid="<%= ii %>" data-colid="1" data-content="" class="xw-cell">
                <td><div data-rowid="<%= ii %>" data-colid="2" data-content="" class="xw-cell">
                <td><div data-rowid="<%= ii %>" data-colid="3" data-content="" class="xw-cell">
                <td><div data-rowid="<%= ii %>" data-colid="4" data-content="" class="xw-cell">
                <td><div data-rowid="<%= ii %>" data-colid="5" data-content="" class="xw-cell">
                <td><div data-rowid="<%= ii %>" data-colid="6" data-content="" class="xw-cell">
                <td><div data-rowid="<%= ii %>" data-colid="7" data-content="" class="xw-cell">
                <td><div data-rowid="<%= ii %>" data-colid="8" data-content="" class="xw-cell">
                <td><div data-rowid="<%= ii %>" data-colid="9" data-content="" class="xw-cell">
                <td><div data-rowid="<%= ii %>" data-colid="10" data-content="" class="xw-cell">
              </tr>
              <% end %>
            </table></td>
        <td rowspan="4"><img name="card_14" src="<%= path_to_image 'card/card_14.jpg' %>"></td>
      </tr>
      <tr valign="top">
        <td rowspan="3"><img name="card_15" src="<%= path_to_image 'card/card_15.jpg' %>"></td>
        <td colspan="2"><img name="card_16" src="<%= path_to_image 'card/card_16C.jpg' %>"></td>
        <td rowspan="3"><img name="card_17" src="<%= path_to_image 'card/card_17.jpg' %>"></td>
      </tr>
      <tr valign="top">
        <td rowspan="2" colspan="2"><img name="card_18" src="<%= path_to_image 'card/card_18.jpg' %>"></td>
      </tr>
      <tr valign="top">
        <td colspan="6"><img name="card_19" src="<%= path_to_image 'card/card_19.jpg' %>"></td>
      </tr>
    </table>
  <% end %></div>
</div>
<script type="text/javascript">
// TODO LIST:
// P1:
// -- Rudimentary Bonus, Tripling, Your Letter Fields
// -- Reading hidden form fields in during initialize for edit
// -- AJAX call to load different card state without page reload
// -- AJAX call to wait on payout stats update on save
// -- AJAX call to save and update payout stats on edit
// P2:
// -- Bonus word UI
// -- Your Letters UI
// -- Tripling Modifier UI
// P3:
// -- Check for cell clicks that cannot grow out to 3 characters
// -- Check for direction toggle capability on cursor movement
// -- Bootstrap dialogs
// -- Cursor blinking
  var $editorCell = null;
  var $hasAltDir = true;
  var $wordCount = 0;
  var $tripleCellCount = 0;

  var $openRange    = null;
  var $oldWordRange = null;
  var $newWordRange = null;

  // TABLES:
  // (X,Y) in horizontal mode yields the same cell as (Y,X) in vertical mode.
  // When orientation changes invert the meaning of up/down and left/right,
  // Tables preserve a standard orientation and so swap their coordinates.
  // These are needed to support Table-to-Cell coordinate mapping in HTML b/c
  // inverting the logical orientation cannot toggle the X,Y coordinates
  // embedded in the tables, so the view logic for mapping from click location
  // to cell object has to have an abstraction that is unaffected by logical
  // orientation swaps.
  //
  // Note that the constrant addressing for non-toggling cell coordinates does
  // NOT prevent the object retrieved in vertical mode from behaving differently
  // from that retrieved in horizontal mode.  Just because the means of lookup
  // is orientation-agnostic doesn't constrain the retrieved objects to also
  // be orientation-agnostic.
  var $horizontalTable = [];
  var $verticalTable = [];

  // Logical Table -- Switching logical tables doesn't change the conceptual
  // cell retrieved by clicking in a UI Table, but it does return an
  // alternate object for the same conceptual cell, but with up/down and
  // left/right inverted.
  var $logicalTable = $horizontalTable;

  // GRIDS:
  // (X,Y) in horizontal mode yields the same cell as (X,Y) in vertical mode
  // Coordinates are constant, orientation of up/down and left/right is not.

  // Physical grids
  var $horizontalGrid = [];
  var $verticalGrid = [];

  // Logical grids
  var $logicalGrid = $horizontalGrid;
  var $altLogicalGrid = $verticalGrid;

  var $rootTable  = $('#lettergrid');
  
  var $blankImage = "<%= path_to_image 'val/blank.png' %>";
  var $cursorImage = "<%= path_to_image 'val/qm.png' %>";
  var $valueImages = $( {
    A: "<%= path_to_image 'val/A.png' %>", B: "<%= path_to_image 'val/B.png' %>",
    C: "<%= path_to_image 'val/C.png' %>", D: "<%= path_to_image 'val/D.png' %>",
    E: "<%= path_to_image 'val/E.png' %>", F: "<%= path_to_image 'val/F.png' %>",
    G: "<%= path_to_image 'val/G.png' %>", H: "<%= path_to_image 'val/H.png' %>",
    I: "<%= path_to_image 'val/I.png' %>", J: "<%= path_to_image 'val/J.png' %>",
    K: "<%= path_to_image 'val/K.png' %>", L: "<%= path_to_image 'val/L.png' %>",
    M: "<%= path_to_image 'val/M.png' %>", N: "<%= path_to_image 'val/N.png' %>",
    O: "<%= path_to_image 'val/O.png' %>", P: "<%= path_to_image 'val/P.png' %>",
    Q: "<%= path_to_image 'val/Q.png' %>", R: "<%= path_to_image 'val/R.png' %>",
    S: "<%= path_to_image 'val/S.png' %>", T: "<%= path_to_image 'val/T.png' %>",
    U: "<%= path_to_image 'val/U.png' %>", V: "<%= path_to_image 'val/V.png' %>",
    W: "<%= path_to_image 'val/W.png' %>", X: "<%= path_to_image 'val/X.png' %>",
    Y: "<%= path_to_image 'val/Y.png' %>", Z: "<%= path_to_image 'val/Z.png' %>"
  } );

  var $wordAttrs = {
    xCoord: 'input:hidden#crossword_word_items_attributes_{idx}_x_coordinate',
    yCoord: 'input:hidden#crossword_word_items_attributes_{idx}_y_coordinate',
    isHoriz: 'input:hidden#crossword_word_items_attributes_{idx}_is_horizontal',
    textValue: 'input:text#crossword_word_items_attributes_{idx}_text_value',
    tripleIndex: 'input:hidden#crossword_word_items_attributes_{idx}_triple_letter_index'
  };
    
  function initialize() {
    var contentTmpl = 
      '<img class="xw-value" src="<%= path_to_image 'val/blank.png'%>"><img class="xw-grid" src="<%= path_to_image 'border/grid.png' %>"><img class="xw-border xw-htop" src="<%= path_to_image 'border/htop.png' %>" /><img class="xw-border xw-hmid" src="<%= path_to_image 'border/hmid.png' %>" /><img class="xw-border xw-hend" src="<%= path_to_image 'border/hend.png' %>" /><img class="xw-border xw-vtop" src="<%= path_to_image 'border/vtop.png' %>" /><img class="xw-border xw-vmid" src="<%= path_to_image 'border/vmid.png' %>" /><img class="xw-border xw-vend" src="<%= path_to_image 'border/vend.png' %>" /><img class="xw-fill xw-revealed" src="<%= path_to_image 'fill/brite1.png' %>" /><img class="xw-fill xw-selected" src="<%= path_to_image 'fill/selected1.png' %>" /><img class="xw-fill xw-mainpath" src="<%= path_to_image 'fill/imageSrc.png' %>" /><img class="xw-fill xw-altpath" src="<%= path_to_image 'fill/altPath2.png' %>" /><img class="xw-fill xw-initial" src="<%= path_to_image 'fill/pink2.png' %>" /></div></td>';
    var selectRowTmpl = 'div[data-rowid="{row}"]';
    var selectColTmpl = 'div[data-colid="{col}"]';

    // Iterate through the cells in document order, adding image data to
    // each cell and building a horizontal doubly linked lists connecting
    // immediate neighbors for horizontal navigability.
    for (var row=0; row<11; row++) {
      var lastHCell = null;
      var lastVCell = null;
      $horizontalTable[row] = [];
      $verticalTable[row]   = [];
      $horizontalGrid[row]  = [];

      var thisRow   = $(selectRowTmpl.format( {row: row}, $rootTable ));
      thisRow.append(contentTmpl);

      thisRow.each(
        function(col, nextElement) { 
          var thisHCell = {
            row: row,
            col: col,
            selfNode: $(nextElement),
            sameRow: thisRow,
            sameCol: null,
            content: {
              current: '', previous: ''
            },
            hasTriple: {
              current: false, previous: false
            },
            open: {
              parallel: { head: 0, tail: 10, length: 11 },
              crossing: { head: 0, tail: 10, length: 11 }
            },
            toLeft: lastHCell,
            toRight: null,
            toAbove: null,
            toBelow: null
          };
          var thisVCell = {
            row: col,
            col: row,
            selfNode: thisHCell.selfNode,
            sameRow: null,
            sameCol: thisRow,
            content: thisHCell.content,
            hasTriple: thisHCell.hasTriple,
            open: {
              parallel: thisHCell.open.crossing,
              crossing: thisHCell.open.parallel
            },
            toLeft: null,
            toRight: null,
            toAbove: thisHCell,
            toBelow: null
          };

          if(col != 0) {
            lastHCell.toRight = thisHCell;
            lastVCell.toBelow = thisVCell;
          }
  
          // Cell coordinates are inverted within the objects to support
          // dimension toggling, but the lookup arrays are not inverted
          // because they are accessed using the physical coordinates on
          // each cell's <dim> tag, which do not change when the edit
          // dimension is toggled.
          lastHCell = thisHCell;
          lastVCell = thisVCell;
          $horizontalTable[row][col] = thisHCell;
          $verticalTable[row][col] = thisVCell;

          // The "Rows" arrays are used for logical lookup when cleaning up
          // bookkeeping info using logical objects rather than selected
          // <div> objects.
          $horizontalGrid[row][col] = thisHCell;
        }
      );
    }

    // Populate a second double linked list between cells in the same column
    // for vertical navigability, and add functions for use by the click and
    // keyboard event handlers that derive subsets of connected cells for word
    // boundary highlighting and cursor position management.
    for (var col=0; col<11; col++) {
      var lastHCell = null;
      var lastVCell = null;
      $verticalGrid[col]   = [];

      var thisCol = $(selectColTmpl.format({col: col}, $rootTable));

      thisCol.each(
        function(row, nextCell) { 
          var thisHCell = $horizontalGrid[row][col];
          var thisVCell = $verticalTable[row][col];

          thisHCell.sameCol = thisCol;
          thisVCell.sameRow = thisCol;
  
          thisHCell.toAbove = lastHCell;
          thisVCell.toLeft  = lastVCell;
  
          if(row != 0) {
            lastHCell.toBelow = thisHCell;
            lastVCell.toRight = thisVCell;
          }
  
          lastHCell = thisHCell;
          lastVCell = thisVCell;
          $verticalGrid[col][row] = thisVCell;
        }
      );
    } // Latter of two intialization "for" loops.

    // Set a handler for the table, setup to recieve calls from 
    $rootTable.on('click', 'div.xw-cell', onClickCell);
    $rootTable.on('contextmenu', 'div.xw-cell', onContextMenu);

    var $wordFilter = ('word01', 'word02', 'word03', 'word04', 'word05', 'word06', 'word07', 'word08', 'word09', 'word10', 'word11', 'word12', 'word13', 'wrod14', 'word15', 'word16', 'word17', 'word18', 'word19', 'word20', 'word21', 'word22');
    $("input.xw-initword").each(
      function(idx, tag) {
        var wordinput = $(tag);
        if (wordinput.val() != '') {
          wordinput.addClass('xw-foundword uneditable-input').removeClass('xw-initword');
        } else {
          wordinput.addClass('xw-blankword').removeClass('xw-initword');
        }
      });

    for( var ii=0; ii<22; ii=ii + 1 ) {
      var x_coordinate = -1;
      var y_coordinate = -1;
      var triple_index = -1;
      var is_horizontal = null;
      var text_value = '';
      $($wordFilter[ii]).each(
        function( idx, tag ) {
          if( idx == 0 ) {
            x_coordinate = $(tag).val();
          } else if( idx == 1 ) {
            y_coordinate = $(tag).val();
          } else if( idx == 2 ) {
            is_horizontal = $(tag).val();
          } else if( idx == 3 ) {
            text_value = $(tag).val();
          } else if( idx == 4 ) {
            :riple_index = $(tag).val();
          }
        }
      );

      if (is_horizontal != null) {
        var cell = $logicalTable[x_coordinate][y_coordinate];
        var len = text_value.length;
        for( var jj=0; jj<len; jj++ ) {
          var nextChar = text_value[jj];
          cell.content.current = nextChar;
          cell.selfNode.data('content', nextChar);
          $('img', cell.selfNode).attr('src', $valueImages.attr(nextChar))
  
          if (jj == triple_index) { cell.selfNode.addClass('xw-triple'); }

          if (is_horizontal) {
            cell = cell.toRight;
          } else {
            cell = cell.toBelow;
          }
        }
      }
    }
  }

  //
  // Javascript Event Handlers
  //

  function onClickCell(event) {
    var wrap = $(this); // $(event.target).parent();
    var row = wrap.data('rowid');
    var col = wrap.data('colid');
    var cellState = $logicalTable[row][col];
  
    if($editorCell != null) {
      if (! isOpen(cellState)) {
        // If another word is already active accept its changes and release 
        // its interests in the cell grid's decoration state.
        closeWordEditor();
      } else if (! isWord(cellState)) {
        if (isWordTail(cellState.toLeft) && (isFilled(cellState.toLeft))) {
          shiftWordTail(cellState.toLeft, cellState);
          moveCursor($editorCell, cellState);
          $editorCell = cellState;

          return true;
        } else if (isWordHead(cellState.toRight) && isFilled(cellState.toRight)) {
          shiftWordHead(cellState.toRight, cellState);
          moveCursor($editorCell, cellState);
          $editorCell = cellState;

          return true;
        } else {
          closeWordEditor();
        }
      } else {
        moveCursor($editorCell, cellState);
        $editorCell = cellState;

        return true;
      }
    }

    // If all 22 words are accounted for, disallow selections that are not 
    // contiguous with an existing word.
    // TODO: Allow extending an existing word into blank space!
    if (isBlank(cellState) && ($wordCount >= 22)) {
      showMaxWordsError();
      return false;
    }

    if(cellState.open.parallel.length < 3) {
      if(cellState.open.crossing.length < 3) {
        showLockedOutCellError(cellState);
        return false;
      }

      toggleDirectionMode();

      $hasAltDir  = false;
      $editorCell = $logicalTable[row][col];
    } else {
      if (cellState.open.crossing.length < 3) {
        $hasAltDir  = false;
      } else {
        $hasAltDir  = true;
      }
      $editorCell = cellState;
    }

    $openRange = $editorCell.open.parallel;
    $oldWordRange =
      bootstrapWordRange($editorCell.row, $editorCell.col, $logicalGrid);
    $newWordRange  = 
      { head:   $oldWordRange.head,
        tail:   $oldWordRange.tail,
        length: $oldWordRange.length };

    $(document).on('keydown', onKeyboardInput);
    decorateOpenWord();
    showCursor();
  }
  
  function onKeyboardInput(event) {
    if ($editorCell == null) { return true; }
  
    if (!event) var event = window.event;

    var keyValue = event.keyCode;
    if( keyValue == null ) { return true; }
  
    // Accept DEL, RETURN, TAB, arrows, and letters.
    if (keyValue >= 65 && keyValue <= 90) { 
      setCharacter(String.fromCharCode(keyValue));
    } else if (keyValue == 8) {
      clearCharacter();   // <BACKSPACE> unsets a character
      return false;
    } else if (keyValue == 999) {
      // <SPACE> marks a tripling multiplier TODO
    } else if (keyValue == 9) {
      if ($hasAltDir) { 
        commitActiveChanges();
        toggleDirectionMode();   // <TAB> toggles horiz/vert direction modes
      } else {                   // and accepts changes. (TODO only accept 
        // showBadToggleError(); // changes after the first change in a toggled
      }                          // direction).
    } else if (keyValue == 27) {
      // TODO:
      // abortWordEditor();  // <ESC> stops editting and rolls back changes
      closeWordEditor();  // <RETURN> stops editting and accepts changes
    } else if (keyValue == 13) {
      closeWordEditor();  // <RETURN> stops editting and accepts changes
    } else if (keyValue == 37) {
      moveCursorLeft();   // <LEFT> moves the cursor left
    } else if (keyValue == 38) {
      moveCursorLeft();   // <UP> moves the cursor up
    } else if (keyValue == 39) {
      moveCursorRight();  // <RIGHT> moves the cursor right
    } else if (keyValue == 40) {
      moveCursorRight();  // <DOWN> moves the cursor down
    }
  
    return true;
  }
  
  function onContextMenu(event) {
    var wrap = $(this); // $(event.target).parent();
    var row = wrap.data('rowid');
    var col = wrap.data('colid');
    var cellState = $logicalTable[row][col];

    if( $tripleCellCount > 0 ) {
      if( cellState.hasTriple.current ) {
        // Render remove triple context option.
      } else if ($tripleCellCount >= 4) {
        // Render unselectable error.
      } else if (isBlank(cellState)) {
        // Render illegal blank target.
      } else if ((isFilled(cellState.toAbove) ||
                  isFilled(cellState.toBellow)) &&
                 (isFilled(cellState.toLeft) ||
                  isFilled(cellState.toRight))) {
        // Render illegal intersection.
      } else {
        // Render add triple context option.
      }
    }

    alert( wrap.get() );
    return false;
  }
  
  //
  // Change-of-context cleanup methods
  // 

  function bootstrapWordRange(rowIdx, colIdx, orientation) {
    var midCell = orientation[rowIdx][colIdx];

    var leftCell, rightCell;
    var lastLeftCell, lastRightCell;
    if (isBlank(midCell)) {
      if (isFilled(midCell.toLeft)) {
        lastLeftCell = midCell.toLeft;
      } else {
        lastLeftCell = midCell;
      }

      if (isFilled(midCell.toRight)) {
        lastRightCell = midCell.toRight;
      } else {
        lastRightCell = midCell;
      }
    } else {
      lastLeftCell = midCell;
      lastRightCell = midCell;
    }
    leftCell = lastLeftCell.toLeft;
    rightCell = lastRightCell.toRight;

    while(isFilled(leftCell)) {
      lastLeftCell = leftCell;
      leftCell = leftCell.toLeft;
    }
    leftCell = lastLeftCell;

    while(isFilled(rightCell)) {
      lastRightCell = rightCell;
      rightCell = rightCell.toRight;
    }
    rightCell = lastRightCell;

    return({
      head:   leftCell.col,
      tail:   rightCell.col,
      length: rightCell.col - leftCell.col + 1
    });
  }

  function closeWordEditor() {
    $(document).off('keydown', onKeyboardInput);

    commitActiveChanges();

    hideCursor();
    removeEditorDecorations();

    $editorCell = null;
  }

  function commitActiveChanges() {
    // var open = cells.slice(openRange.openHead, openRange.openTail);
    var row = $editorCell.row;
    var wrc = $newWordRange;
    var wrp = $oldWordRange;

    // Apply changes to cells in the open range first.
    var first;
    if( wrc.head < wrp.head ) { first = wrc.head; } else { first = wrp.head; }

    var last;
    if( wrc.tail > wrp.tail ) { last = wrc.tail; } else { last = wrp.tail; }

    for( var ii=first; ii<=last; ii++ ) {
      var currentCell = $logicalGrid[row][ii];
      currentCell.content.previous = currentCell.content.current;
      currentCell.hasTriple.previous = currentCell.hasTriple.current;
    }
    
    // Re-evaluate the open ranges of logical rows above and below
    // only if there were any changes that could affect them.  If the
    // head or tail moved and the length did not remain unity, the changes
    // have an impact. (TODO!)
    // if ((wrc.head != wrp.head || wrc.tail != wrp.tail) &&
    //     (wrc.length != 1 || wrp.length != 1)) {
      refreshOpenRanges();
    // }
  }

  // Let 'a', 'b', and 'c' designate any three consecutive cells, with
  // valid corner cases when 'a' or 'c' is null at the graph edges, but with
  // 'b' != null as an invariant.  Iterate through all 'b' values from left to
  // right.  On each iteration, label cells immediately above, below, and on
  // a diagonal to the right as follows:
  //
  // - m n
  // a b c
  // - p q
  // 
  // The task of finding open regions amounts to finding all b such that either
  // m and n are filled or p and q are filled, or m, n, p, and q are all filled.
  // There is an open region that closes at each such b value.  The region
  // always begins at the first preceding "b" value to not close a region.  How
  // its end points are defined depends on the state of "c".
  // -- If "c" is filled, then "a" is the last cell of the preceding region,
  //    "b" must be empty and it both begins and ends a second open region of
  //    size unity, which renders it incapable of supporting a word.  Finally,
  //    "c" is the beginning of a third region whose closing end is unknown.
  // -- If "c" is empty, then "b" is the last cell of the preceding region, and
  //    "c" begins a new region (but if m/n or p/q continue to the right, that
  //    new region will get truncated to unity very quickly.
  function refreshOpenRanges() {
    $wordCount = 0;
    $('input.xw-foundword').removeClass('xw-foundword').addClass('xw-blankword');
    $('div.xw-cell', $rootTable).removeClass('xw-shortrow xw-shortcol');

    var colTrack = [ ];
    for( var ii=0; ii<11; ii++ ) {
      colTrack[ii] = { openStart: null, wordRun: $() };
    }

    // Check down the row.  If a cell is populated, it must be in an unlocked
    // space by definition.  If a cell is blank, check its corner adjacencies,
    // and if none are full, it is unlocked.
    //
    // When a locked cell is found, openStart has the index of the first 
    // preceding unlocked cell.  Set every cell between it and the present with
    // the open region bounds discovered, then increment openStart and keep 
    // on searching.
    for( var ii=0; ii<11; ii++ ) {
      var rowTrack =
        { openStart: null, wordRun: $() };

      for( var jj=0; jj<11; jj++ ) {
        var thisCell = $horizontalGrid[ii][jj];
        // var thisCell = $logicalTable[ii][jj];
        // var thisCell = $logicalGrid[ii][jj];

        // Do both horizontal and vertical word tracking first.
        if (! isFilled(thisCell)) {
          markWordBoundary(rowTrack, 'xw-shortrow');
          markWordBoundary(colTrack[jj], 'xw-shortcol');
        } else {
          rowTrack.wordRun = rowTrack.wordRun.add(thisCell.selfNode);
          colTrack[jj].wordRun = colTrack[jj].wordRun.add(thisCell.selfNode);
        }

        // Next, check horizontal open region boundaries.
        if ((isFilled(thisCell.toAbove) &&
             isFilled(thisCell.toAbove.toRight)) ||
            (isFilled(thisCell.toBelow) &&
             isFilled(thisCell.toBelow.toRight))) {
          if(isFilled(thisCell.toRight)) {
            markRowOpenRange(rowTrack.openStart, thisCell.toLeft);
            markRowLockedCell(thisCell);
          } else {
            markRowOpenRange(rowTrack.openStart, thisCell);
          }

          rowTrack.openStart = thisCell.toRight;
        }

        // Next, check horizontal open region boundaries.
        if ((isFilled(thisCell.toLeft) &&
             isFilled(thisCell.toLeft.toBelow)) ||
            (isFilled(thisCell.toRight) &&
             isFilled(thisCell.toRight.toBelow))) {
          if(isFilled(thisCell.toBelow)) { markColOpenRange(colTrack[jj].openStart, thisCell.toAbove);
            markColLockedCell(thisCell);
          } else {
            markColOpenRange(colTrack[jj].openStart, thisCell);
          }

          colTrack[jj].openStart = thisCell.toBelow;
        }
      }
        
      // Close off the remaining horizontal words and open horizontal region
      // boundary discoveries at end-of-row.
      markWordBoundary(rowTrack, 'xw-shortrow');
      markRowOpenRange(rowTrack.openStart, thisCell);
    }
  
    // Close off the remaining vertical words and open vertical region boundary
    // discoveries at end-of-grid.
    for( var ii=0; ii<11; ii++ ) {
      markWordBoundary(colTrack[ii], 'xw-shortcol');
    }
    for( var ii=0; ii<11; ii++ ) {
      // markColOpenRange(colTrack[ii].openStart, $logicalTable[10][ii]);
      // markColOpenRange(colTrack[ii].openStart, $logicalGrid[10][ii]);
      markColOpenRange(colTrack[ii].openStart, $horizontalGrid[10][ii]);
    }
  }

  function markRowLockedCell(cell) {
    cell.open.parallel.head = cell.col;
    cell.open.parallel.tail = cell.col;
    cell.open.parallel.length = 1;
  }

  function markColLockedCell(cell) {
    cell.open.crossing.head = cell.row;
    cell.open.crossing.tail = cell.row;
    cell.open.crossing.length = 1;
  }

  function markRowOpenRange(headCell, tailCell) {
    var regionCell, rangeLen, finalIdx;

    if(headCell == null) {
      if(tailCell == null) { return; }

      rangeLen = tailCell.col + 1;
      finalIdx = tailCell.col;
      regionCell = tailCell;
      while(regionCell != headCell) {
        regionCell.open.parallel.head = 0;
        regionCell.open.parallel.tail = finalIdx;
        regionCell.open.parallel.length = rangeLen;
        regionCell = regionCell.toLeft;
      }
    } else {
      if(tailCell == null) {
        rangeLen = 11 - headCell.col;
        finalIdx = 10;
      } else if(headCell.col >= tailCell.col) {
        return markRowLockedCell(tailCell);
      } else {
        rangeLen = tailCell.col - headCell.col + 1;
        finalIdx = tailCell.col;
      }

      regionCell = headCell;
      while(regionCell != tailCell) {
        regionCell.open.parallel.head = headCell.col;
        regionCell.open.parallel.tail = finalIdx;
        regionCell.open.parallel.length = rangeLen;

        regionCell = regionCell.toRight;
      }
    }
  }

  function markColOpenRange(headCell, tailCell) {
    var regionCell, rangeLen, finalIdx;

    if(headCell == null) {
      if(tailCell == null) { return; }

      rangeLen = tailCell.row + 1;
      finalIdx = tailCell.row;
      regionCell = tailCell;
      while(regionCell != headCell) {
        regionCell.open.crossing.head = 0;
        regionCell.open.crossing.tail = finalIdx;
        regionCell.open.crossing.length = rangeLen;
        regionCell = regionCell.toAbove;
      }
    } else {
      if(tailCell == null) {
        rangeLen = 11 - headCell.row;
        finalIdx = 10;
      } else if(headCell.row >= tailCell.row) {
        return markColLockedCell(tailCell);
      } else {
        rangeLen = tailCell.row - headCell.row + 1;
        finalIdx = tailCell.row;
      }

      regionCell = headCell;
      while(regionCell != tailCell) {
        regionCell.open.crossing.head = headCell.row;
        regionCell.open.crossing.tail = finalIdx;
        regionCell.open.crossing.length = rangeLen;

        regionCell = regionCell.toBelow;
      }
    }
  }

  function markWordBoundary(trackObj, shortClass) {
    if(trackObj.wordRun.size() > 0) {
      if(trackObj.wordRun.size() < 3) {
        trackObj.wordRun.addClass(shortClass);
      } else {
        var subst = { idx: $wordCount };
        var text_value = '';

        trackObj.wordRun.each( function(letterIdx, cell) { 
          var jcell = $(cell);

          text_value = text_value + jcell.data('content');

          if (jcell.data('triple')) {
            $($wordAttrs.tripleIndex.format(subst)).val(letterIdx);
          }
        });
        
        $($wordAttrs.textValue.format(subst)).removeClass('xw-blankword').addClass('xw-foundword uneditable-input').val(text_value);
        $($wordAttrs.xCoord.format(subst)).val(
          trackObj.wordRun.first().data('rowid'));
        $($wordAttrs.yCoord.format(subst)).val(
          trackObj.wordRun.first().data('colid'));

        if( shortClass == "xw-shortrow" ) {
          $($wordAttrs.isHoriz.format(subst)).val(true);
        } else {
          $($wordAttrs.isHoriz.format(subst)).val(false);
        }

        $wordCount = $wordCount + 1;
      }

      trackObj.wordRun = $()
    }
  }

  //
  // Orientation-aware cell decoration.  Not a public interface
  //

  var $horizontalStrategy = {
    toggleDirectionMode: function() {
      $dirModeStrategy = $verticalStrategy;
      $logicalTable = $verticalTable;
      $altLogicalGrid = $logicalGrid;
      $logicalGrid = $verticalGrid;
      
      if($editorCell != null) {
        $editorCell = $logicalGrid[$editorCell.col][$editorCell.row];
      }
    },

    decorateParallel: function(open, word, focus) {
      open.addClass('xw-open xw-asrow');
      word.addClass('xw-word xw-asrow');
    },

    decorateCrossing: function(open, word, focus) {
      open.not(focus).addClass('xw-tabopen xw-astabcol');
      word.not(focus).addClass('xw-tabword xw-astabcol');
    },

    decorateShortWord: function(wordRun, orientation) {
      if(orientation == $logicalGrid) {
        wordRun.addClass('xw-shortcol');
      } else {
        wordRun.addClass('xw-shortrow');
      }
    }
  };

  var $verticalStrategy = {
    toggleDirectionMode: function() {
      $dirModeStrategy = $horizontalStrategy;
      $logicalTable = $horizontalTable;
      $altLogicalGrid = $logicalGrid;
      $logicalGrid = $horizontalGrid;

      if ($editorCell != null) {
        $editorCell = $logicalGrid[$editorCell.col][$editorCell.row];
      }
    },

    decorateParallel: function(open, word, focus) {
      open.addClass('xw-open xw-ascol');
      word.addClass('xw-word xw-ascol');
    },

    decorateCrossing: function(open, word, focus) {
      open.not(focus).addClass('xw-tabopen xw-astabrow');
      word.not(focus).addClass('xw-tabword xw-astabrow');
    },

    decorateShortWord: function(wordRun, orientation) {
      if(orientation == $logicalGrid) {
        wordRun.addClass('xw-shortrow');
      } else {
        wordRun.addClass('xw-shortcol');
      }
    }
  };

  var $dirModeStrategy = $horizontalStrategy

  function toggleDirectionMode() {
    $dirModeStrategy.toggleDirectionMode();

    if ($editorCell != null) {
      $openRange = $editorCell.open.parallel;
      $oldWordRange =
         bootstrapWordRange($editorCell.row, $editorCell.col, $logicalGrid);
      $newWordRange =
         { head:   $oldWordRange.head,
           tail:   $oldWordRange.tail,
           length: $oldWordRange.length };
    }
  }

  function removeEditorDecorations() {
    $('div.xw-cell', $rootTable).removeClass(
      'xw-openhead xw-opentail xw-midopen xw-open xw-wordhead xw-wordtail xw-midword xw-word xw-tabopenhead xw-tabopentail xw-midtabopen xw-tabopen xw-tabwordhead xw-tabwordtail xw-midtabword xw-tabword xw-asrow xw-ascol xw-astabrow xw-astabcol');
  }

  function decorateOpenWord() {
    decorateDimension(
      $editorCell, $editorCell.sameRow, $openRange, $newWordRange,
      $dirModeStrategy.decorateParallel,
      'xw-openhead', 'xw-opentail', 'xw-midopen',
      'xw-wordhead', 'xw-wordtail', 'xw-midword'
    );

    if($hasAltDir) {
      var altWordRange =
        bootstrapWordRange($editorCell.col, $editorCell.row, $altLogicalGrid);

      decorateDimension(
        $editorCell, $editorCell.sameCol, $openRange, altWordRange,
        $dirModeStrategy.decorateCrossing,
        'xw-tabopenhead', 'xw-tabopentail', 'xw-midtabopen',
        'xw-tabwordhead', 'xw-tabwordtail', 'xw-midtabword'
      );
    }
  }

  function decorateShortWord(wordRun, orientation) {
    $dirModeStrategy.decorateShortWord(wordRun, orientation);
  }

  function decorateDimension(focus, cells, openRange, wordRange, dimMethod, openhead, opentail, midopen, wordhead, wordtail, midword) {
    var open = cells.slice(openRange.head, openRange.tail + 1);
    var word = cells.slice(wordRange.head, wordRange.tail + 1);

    dimMethod(open, word, focus.selfNode);

    open.first().addClass(openhead);
    open.last().addClass(opentail);
    open.slice(1, openRange.length - 1).addClass(midopen);

    word.first().addClass(wordhead);
    word.last().addClass(wordtail);
    word.slice(1, wordRange.length - 1).addClass(midword);
  }
      
  function shiftWordHead(fromCell, toCell) {
    if(toCell.col > $newWordRange.tail) { 
      alert('Coding error!  Illegal move of word head to <' + toCell.col + '> after word at <{head},{tail}>!'.format($newWordRange));
    } else if((toCell.col < $openRange.head) ||
              (toCell.col > $openRange.tail)) {
      alert('Coding errror!  Illegal move of word head to <' + toCell.col + '> beyond open range of <{head},{tail}>!'.format($openRange));
    }

    if(fromCell.col < toCell.col) {
      // Head is moving right.  Prune word markers from all cells until the new
      // destination is reached.  Remove a mid-word tag from the new destination
      // cell, and apply the head tag.  If that cell happens to be the tail,
      // then removing the mid tag will be a harmless no-op.  Its not worth 
      // exerting to test for tail-ness.
      var nextCell = fromCell;
      while(nextCell != toCell) {
        nextCell.selfNode.removeClass('xw-wordhead xw-word xw-midword');
        nextCell = nextCell.toRight;
      }

      toCell.selfNode.removeClass('xw-midword').addClass('xw-wordhead');
    } else {
      // Head is moving left.  Prune old head marker from head and then add a
      // mid marker to every cell leading up to the new head location.  If the
      // old head is also currently the tail, make one exception and do not
      // apply the mid label there--it will retain its "tail" class.
      var nextCell = fromCell;
      nextCell.selfNode.removeClass('xw-wordhead');
      if(isWordTail(nextCell)) {
        nextCell = nextCell.toRight;
      }
      while(nextCell != toCell) {
        nextCell.selfNode.addClass('xw-word xw-midword');
        nextCell = nextCell.toRight;
      }

      toCell.selfNode.addClass('xw-word xw-wordtail');
    }

    $newWordRange.head = toCell.col;
  }

  function shiftWordTail(fromCell, toCell) {
    if(toCell.col < $newWordRange.head) { 
      alert('Coding error!  Illegal move of word tail to <' + toCell.col + '> before word at <{head},{tail}>!'.format($newWordRange));
    } else if((toCell.col < $openRange.head) ||
              (toCell.col > $openRange.tail)) {
      alert('Coding errror!  Illegal move of word tail to <' + toCell.col + '> beyond open range of <{head},{tail}>!'.format($openRange));
    }

    if(fromCell.col > toCell.col) {
      // Head is moving right.  Prune word markers from all cells until the new
      // destination is reached.  Remove a mid-word tag from the new destination
      // cell, and apply the head tag.  If that cell happens to be the tail,
      // then removing the mid tag will be a harmless no-op.  Its not worth 
      // exerting to test for tail-ness.
      var nextCell = fromCell;
      while(nextCell != toCell) {
        nextCell.selfNode.removeClass('xw-wordtail xw-word xw-midword');
        nextCell = nextCell.toLeft;
      }

      toCell.selfNode.removeClass('xw-midword').addClass('xw-wordtail');
    } else {
      // Head is moving left.  Prune old head marker from head and then add a
      // mid marker to every cell leading up to the new head location.  If the
      // old head is also currently the tail, make one exception and do not
      // apply the mid label there--it will retain its "tail" class.
      var nextCell = fromCell;
      fromCell.selfNode.removeClass('xw-wordtail');
      if(isWordHead(nextCell)) { nextCell = fromCell.toRight; }

      while(nextCell != toCell) {
        nextCell.selfNode.addClass('xw-word xw-midword');
        nextCell = nextCell.toRight;
      }

      toCell.selfNode.addClass('xw-word xw-wordtail');
    }

    $newWordRange.tail = toCell.col;
  }

  function moveCursor(fromCell, toCell) {
    var cursorReplacement
    if (isBlank(fromCell)) {
      cursorReplacement = $blankImage
    } else {
      cursorReplacement = $valueImages.attr($editorCell.content.current);
    }

    fromCell.sameCol.removeClass(
      'xw-tabopenhead xw-tabopentail xw-midtabopen xw-tabopen xw-tabwordhead xw-tabwordtail xw-midtabword xw-tabword xw-astabrow xw-astabcol');

    if(toCell.open.crossing.length < 3) {
      $hasAltDir  = false;
    } else {
      $hasAltDir  = true;

      var altWordRange =
        bootstrapWordRange(toCell.col, toCell.row, $altLogicalGrid);
      decorateDimension(
        toCell, toCell.sameCol, toCell.open.crossing, altWordRange,
        $dirModeStrategy.decorateCrossing,
        'xw-tabopenhead', 'xw-tabopentail', 'xw-midtabopen',
        'xw-tabwordhead', 'xw-tabwordtail', 'xw-midtabword'
      );
    }

    $('img.xw-value', fromCell.selfNode).attr('src', cursorReplacement);
    $('img.xw-value', toCell.selfNode).attr('src', $cursorImage);
  }

  //
  // Content If Not Null Helpers
  //

  // isBlank() and isFilled() each return false on null input.  Depending on
  // how null is expected to be handled, it may be favorible to negate the
  // result of the check opposite what is desired.
  //
  // e.g. (cell != null && isBlank(cell)) can be written more succintly as
  //      (! isFilled(cell)) without loss of correct null handling, whereas
  //      (isBlank(cell)) would cause bugs on null input.
  //
  // +=======+===========+============+
  // | INPUT | isBlank() | isFilled() |
  // +=======+===========+============+
  // | null  |   FALSE   |    FALSE   |
  // |  'c'  |   FALSE   |    TRUE    |
  // |  ''   |   TRUE    |    FALSE   |
  // +=======+===========+============+
  function isBlank(cell) {
    return ((cell != null) && (cell.content.current == ''));
  }

  function isFilled(cell) {
    return ((cell != null) && (cell.content.current != ''));
  }

  function isOpen(cell) {
    return ((cell != null) && (cell.selfNode.hasClass('xw-open')));
  }

  function isOpenHead(cell) {
    return ((cell != null) && (cell.selfNode.hasClass('xw-openhead')));
  }

  function isOpenTail(cell) {
    return ((cell != null) && (cell.selfNode.hasClass('xw-opentail')));
  }

  function isWord(cell) {
    return ((cell != null) && (cell.selfNode.hasClass('xw-word')));
  }

  function isWordHead(cell) {
    return ((cell != null) && (cell.selfNode.hasClass('xw-wordhead')));
  }

  function isWordTail(cell) {
    return ((cell != null) && (cell.selfNode.hasClass('xw-wordtail')));
  }

  function isTabOpen(cell) {
    return ((cell != null) && (cell.selfNode.hasClass('xw-tabopen')));
  }

  function isTabOpenHead(cell) {
    return ((cell != null) && (cell.selfNode.hasClass('xw-tabopenhead')));
  }

  function isTabOpenTail(cell) {
    return ((cell != null) && (cell.selfNode.hasClass('xw-tabopentail')));
  }

  function isTabWord(cell) {
    return ((cell != null) && (cell.selfNode.hasClass('xw-tabword')));
  }

  function isTabWordHead(cell) {
    return ((cell != null) && (cell.selfNode.hasClass('xw-tabwordhead')));
  }

  function isTabWordTail(cell) {
    return ((cell != null) && (cell.selfNode.hasClass('xw-tabwordtail')));
  }

  function getWordEnd() {
    var nextCell = $editorCell;

    while (! isWordTail(nextCell)) {
      nextCell = nextCell.toRight;
    }

    return nextCell;
  }

  //
  // Cursor management interface
  //

  function showCursor() {
    $('img.xw-value', $editorCell.selfNode).attr('src', $cursorImage);
  }

  function hideCursor() {
    var cursorReplacement;

    if (isBlank($editorCell)) {
      cursorReplacement = $blankImage
    } else {
      cursorReplacement = $valueImages.attr($editorCell.content.current);
    }

    $('img.xw-value', $editorCell.selfNode).attr('src', cursorReplacement);
  }

  function moveCursorRight() {
    var rightCell = $editorCell.toRight;

    if (! isOpen(rightCell)) { return }

    if ((! isWord(rightCell)) &&
        ((! isWord($editorCell)) || isBlank($editorCell))) { return }

    if (isWordTail($editorCell)) {
      moveCursor($editorCell, rightCell);
      shiftWordTail($editorCell, rightCell);
    } else if (isBlank($editorCell) && isWordHead($editorCell)) {
      moveCursor($editorCell, rightCell);
      shiftWordHead($editorCell, rightCell);
    } else {
      moveCursor($editorCell, rightCell);
    }

    $editorCell = rightCell;
  }

  function moveCursorLeft() {
    var leftCell = $editorCell.toLeft;

    if (! isOpen(leftCell)) { return }

    if ((! isWord(leftCell)) &&
        ((! isWord($editorCell)) || isBlank($editorCell))) { return }

    if (isWordHead($editorCell)) {
      moveCursor($editorCell, leftCell);
      shiftWordHead($editorCell, leftCell);
    } else if (isBlank($editorCell) && isWordTail($editorCell)) {
      moveCursor($editorCell, leftCell);
      shiftWordTail($editorCell, leftCell);
    } else {
      moveCursor($editorCell, leftCell);
    }

    $editorCell = leftCell;
  }

  //
  // Content manipulation -- setCharacter() and clearCharacter()
  //

  function setCharacter(c) {
    $editorCell.content.current = c;
    $editorCell.selfNode.data('content', c);
    moveCursorRight();
  }

  function clearCharacter() {
    // Backspace removes a character left of the current cell and therefore
    // does not apply to the top cell of a word.
    if (isWordHead($editorCell)) { return false; }
  
    // Shift all content down by one cell, then shrink the word region by one.
    var pruneCell = getWordEnd();
    var thisCell  = $editorCell.toLeft;
    var thisImg   = $('img.xw-value', thisCell.selfNode);
    var nextCell  = $editorCell;
    var nextImg   = null;
    while (thisCell != pruneCell) {
      thisCell.content.current = nextCell.content.current;
      thisCell.selfNode.data('content', thisCell.content.current);
  
      nextImg  = $('img.xw-value', nextCell.selfNode);
      thisImg.attr('src', nextImg.attr('src'));
      
      thisCell = nextCell;
      thisImg  = nextImg;
      nextCell = thisCell.toRight;
    }
  
    shiftWordTail(pruneCell, pruneCell.toLeft);
    moveCursorLeft();
  }

  //
  // Active/Inactive/Same(Row|Col) Highlight Manipulation
  //

  //
  // Error Modal Displays
  //

  function showMaxWordsError() { alert('Max Words'); return false; }

  function findWords( ) {
    $words = [];
    
    for (var row=0; row<11; row++) {
      for (var col=0; col<11; col++) {
      }
    }
  }

  initialize();
</script>
